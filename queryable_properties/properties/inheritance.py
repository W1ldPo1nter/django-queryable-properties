# -*- coding: utf-8 -*-
from collections import OrderedDict
from copy import deepcopy
from inspect import isclass

import six
from django.db.models import CharField, Model

from ..compat import get_model
from ..utils.internal import QueryPath
from .base import QueryableProperty, QueryablePropertyReference
from .mixins import AnnotationGetterMixin, IgnoreCacheMixin
from .operations import SelectRelatedOperation


class InheritanceModelProperty(AnnotationGetterMixin, QueryableProperty):
    """
    A property that returns information about the actual model class of objects
    in inheritance scenarios.
    """

    #: A shared cache that holds a dictionary per model class. The
    #: dictionaries contain child model classes as keys and their corresponding
    #: query paths as values.
    _child_paths = {}

    def __init__(self, value_generator, output_field, depth=None, **kwargs):
        """
        Initialize a new property that returns information about the actual
        model class of objects in inheritance scenarios.

        :param value_generator: A callable that returns the actual value to be
                                represented for a given model class. Must take
                                a model class as its first argument.
        :type value_generator: function
        :param output_field: The output field to use for this property, which
                             must be able to hold the values generated by
                             the given value generator.
        :type output_field: django.db.models.Field
        :param depth: The maximum depth of the inheritance hierarchy to follow.
                      Instances of model classes below this maximum depth will
                      be treated as objects of the maximum depth. If not
                      provided, no maximum depth will be enforced.
        :type depth: int | None
        """
        self.value_generator = value_generator
        self.output_field = output_field
        self.depth = depth
        super(InheritanceModelProperty, self).__init__(**kwargs)

    def _get_child_paths(self, model):
        """
        Get a dictionary containg child model classes and their respective
        query paths for the given model.

        :param type model: The model to get the child paths for.
        :return: A dictionary containg child model classes as keys and their
                 respective query paths as values.
        :rtype: OrderedDict[type, QueryPath]
        """
        model = model._meta.proxy_for_model or model
        child_paths = self._child_paths.get(model)
        if child_paths is None:
            from django.db.models.fields.related import ForeignObjectRel

            child_paths = OrderedDict()
            for field in model._meta.get_fields(include_parents=False, include_hidden=False):
                if isinstance(field, ForeignObjectRel) and field.parent_link:
                    path = QueryPath(field.name)
                    for sub_model, sub_path in six.iteritems(self._get_child_paths(field.related_model)):
                        child_paths[sub_model] = path + sub_path
                    child_paths[field.related_model] = path
            self._child_paths[model] = child_paths
        return child_paths

    def get_annotation(self, cls):
        from django.db.models import Case, Value, When

        cases = (
            When((query_path + 'isnull').build_filter(False), then=Value(self.value_generator(child_model)))
            for child_model, query_path in six.iteritems(self._get_child_paths(cls))
            if self.depth is None or len(query_path) <= self.depth
        )
        return Case(*cases, default=Value(self.value_generator(cls)), output_field=self.output_field)


class InheritanceObjectProperty(IgnoreCacheMixin, InheritanceModelProperty):

    def __init__(self, depth=None, **kwargs):
        super(InheritanceObjectProperty, self).__init__(
            value_generator=lambda cls: '.'.join((cls._meta.app_label, cls._meta.object_name)),
            output_field=CharField(),
            depth=depth,
            **kwargs
        )

    def _resolve(self, model=None, relation_path=QueryPath(), remaining_path=QueryPath()):
        return InheritanceObjectPropertyReference(self, model or self.model, relation_path), remaining_path

    def get_value(self, obj):
        if self._descriptor.has_cached_value(obj):
            cached_value = self._descriptor.get_cached_value(obj)
            if isinstance(cached_value, Model):
                # The cached value is already the final model object, so it can
                # be returned as-is.
                return cached_value

            # The cached value is a string in '<app_label>.<ModelName>' format
            # while child relations should have been fetched via
            # select_related. Determine the actual model class and determine
            # the path to follow to get the actual child instance.
            child_obj = deepcopy(obj)
            model = get_model(*cached_value.split('.', 1))
            for part in self._get_child_paths(obj.__class__).get(model, QueryPath()):
                child_obj = getattr(child_obj, part)
        else:
            # No cached value. Perform a query utilizing this property and use
            # the value from its final result. This allows to re-use the query-
            # level implementation including the select_related setup.
            queryset = self.get_queryset_for_object(obj).select_properties(self.name)
            child_obj = getattr(queryset.get(), self.name)

        if self.cached or self._descriptor.has_cached_value(obj):
            self._descriptor.set_cached_value(obj, child_obj)
        return child_obj

    def get_filter(self, cls, lookup, value):
        filter_value = value
        if isinstance(value, self.model) or (isclass(value) and issubclass(value, self.model)):
            filter_value = self.value_generator(value)
        condition = super(InheritanceObjectProperty, self).get_filter(cls, lookup, filter_value)
        if isinstance(value, self.model):
            condition &= (QueryPath('pk') + lookup).build_filter(value.pk)
        return condition


class InheritanceObjectPropertyReference(QueryablePropertyReference):
    __slots__ = ()

    def annotate_query(self, query, full_group_by, select=False, remaining_path=QueryPath()):
        if select:
            fields = (child_path.as_str() for child_path in six.itervalues(self.property._get_child_paths(self.model))
                      if self.property.depth is None or len(child_path) <= self.property.depth)
            query._lazy_queryable_property_operations.append(SelectRelatedOperation(*fields))
        return super(InheritanceObjectPropertyReference, self).annotate_query(query, full_group_by, select,
                                                                              remaining_path)
